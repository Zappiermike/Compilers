terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal LPAREN, RPAREN, EQUALS;
terminal UMINUS, ILLEGAL_CHAR;

//Added most of the following terminals listed below based on requirements listed in the project
terminal String NUMBER, LETTER, INT;
terminal SEMI, LCURLY, RCURLY, COMMA;

non terminal Procedure program;
non terminal Stmt stmt;


 /** Added a new non-terminal Statement called stmts. This is used for the last phase in the project
  * it takes care of cases when we want multiple statements within the program
  */
non terminal Stmt stmts;
non terminal Expr expr;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left UMINUS;


/** Program was heavily modified to work for the fourth phase in the project. We added an outline 
 *  for what the program should expect. This included the keyword int, followed by some name, with
 *  parentheses and an open curly bracket. Inside that contains the statements that will be executed.
 *  Each statement is separated by a semicolon that we created from the third phase. Following the 
 *  statements, we end the program with a right curly bracket.
 */
program ::= INT:i LETTER:l LPAREN RPAREN LCURLY stmts:s RCURLY 
            {: RESULT = new Procedure(l,
                                      new SequenceStmt(s,
                                                       new ReturnStmt(new ConstExpr(0)))); :}
            ;

//Added our keyword SEMI following each statement according to phase three
stmt ::= expr:e SEMI
         {: RESULT = new ExprStmt(e); :}
         |	          
         // Added this parsing expression for declarations
	     INT LETTER:l SEMI
	     {: RESULT = new DeclarationStmt(l); :}
	     |
	     INT LETTER:key EQUALS expr:value SEMI
	     {: RESULT = new SequenceStmt(new DeclarationStmt(key), new AssignmentStmt(key, value)); :}  
	     |
	     LETTER:key EQUALS expr:value SEMI
	     {: RESULT = new AssignmentStmt(key, value); :}  
	     |
         INT LETTER:l COMMA stmt:s
         {: RESULT = new SequenceStmt(new DeclarationStmt(l),s); :}
         |
         LETTER:l COMMA stmt:s
         {: RESULT = new SequenceStmt(new DeclarationStmt(l),s); :}
         |
         LETTER:l EQUALS expr:e COMMA stmt:s
         {: RESULT = new SequenceStmt(new SequenceStmt(new DeclarationStmt(l), new AssignmentStmt(l,e)), s); :}     
         |
         INT LETTER:l EQUALS expr:e COMMA stmt:s
         {: RESULT = new SequenceStmt(new SequenceStmt(new DeclarationStmt(l), new AssignmentStmt(l,e)), s); :}         
         ;
         
         
         
/**Created this new statement called stmts to handle cases where we want multiple statements within the program
 * otherwise, if no arguments are given, the program will return nothing.
 */
stmts ::= {: RESULT = new EmptyStmt(); :}
          |
          stmt:s stmts:ss
          {: RESULT = new SequenceStmt(s, ss); :}
          ;
          

expr      ::= expr:l PLUS expr:r
              {: RESULT = new SumExpr(l, r); :}
	      |
              expr:l MINUS expr:r
              {: RESULT = new DifferenceExpr(l, r); :}
	      |
              expr:l TIMES expr:r
              {: RESULT = new ProductExpr(l, r); :}
	      |
              expr:l DIVIDE expr:r
              {: RESULT = new QuotientExpr(l, r); :}
	      |
              expr:l MOD expr:r
              {: RESULT = new RemainderExpr(l, r); :}
	      |
              MINUS expr:e
              {: RESULT = new DifferenceExpr(new ConstExpr(0), e); :}
 	      %prec UMINUS
	      |
              NUMBER:n
              {: RESULT = new ConstExpr(Integer.parseInt(n)); :}
	      |
	          /**Added this expression based on phase two in the project. This allows the program to accept 
	           * procedures to be called with names. LETTER:l clumps the letters together of the name that
	           * the user has created i.e. "println"
	           */
	          LETTER:l LPAREN expr:e RPAREN 
              {: RESULT = new CallExpr(l, e); :}
	      |
              LPAREN expr:e RPAREN
              {: RESULT = e; :}
          |
              LETTER:l
              {: RESULT = new LoadExpr(l); :}
	      ;
