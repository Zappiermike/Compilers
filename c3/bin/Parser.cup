terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal LPAREN, RPAREN;
terminal UMINUS, ILLEGAL_CHAR;


//Added most of the following terminals listed below based on requirements listed in the project
terminal String NUMBER, LETTER, INT;
terminal SEMI, LCURLY, RCURLY, COMMA, EQUALS;
terminal MORE, LESS, MOREEQ, LESSEQ, EQEQ, NOTEQ;


non terminal Procedure program;
non terminal Stmt stmt;


/** Added a new non-terminal Statements called stmts, decl, and decls. stmts takes care of 
 * cases when we want multiple statements within the program. decl and decls handle the
 * situation when we want to define/assign multiple variables/values within one line,
 * each command being separated by a comma.
 */
non terminal Stmt stmts;
non terminal Expr expr;
non terminal Stmt decl;
non terminal Stmt decls;


precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence nonassoc MORE, LESS, MOREEQ, LESSEQ, EQEQ, NOTEQ;
precedence left UMINUS;



/** Program was heavily modified to work for the fourth phase in the project. We added an outline 
 *  for what the program should expect. This included the keyword int, followed by some name, with
 *  parentheses and an open curly bracket. Inside that contains the statements that will be executed.
 *  Each statement is separated by a semicolon that we created from the third phase. Following the 
 *  statements, we end the program with a right curly bracket.
 */
program ::= INT:i LETTER:l LPAREN RPAREN LCURLY stmts:s RCURLY 
            {: RESULT = new Procedure(l,
                                      new SequenceStmt(s,
                                                       new ReturnStmt(new ConstExpr(0)))); :}
            ;



/** Statement has three options, the first is to take an expression followed by a semicolon.
 * The second option is when we have multiple commands occurring in the same line. This calls
 * our declaration decls. We continue running decls until a semicolon is seen.
 * The third option is an assignment statement where we want to assign some value to an already 
 * defined variable.
 */
stmt ::= expr:e SEMI
         {: RESULT = new ExprStmt(e); :}
         |
         INT decls:ds SEMI
         {: RESULT = ds; :}
         |
         LETTER:l EQUALS expr:e SEMI
         {: RESULT = new AssignmentStmt(l,e, lleft); :}
         ;
         
         
         
/** decl is a statement that gets called when the parser comes across something that needs to be 
 * defined. There are two options. The first is where we just define the variable name. There is
 * no need to add the INT or SEMI portion as decl is already contained between those two in stmt.
 * The second option is where we are declaring the variable as well as assigning it a value.
 */
decl ::= LETTER:l
         {: RESULT = new DeclarationStmt(l, lleft); :}
         |
         LETTER:l EQUALS expr:e
         {: RESULT = new SequenceStmt(new DeclarationStmt(l, lleft), new AssignmentStmt(l,e,lleft)); :}
		 ;
		 
		 
	
/** decls is a statment that gets called when the parser runs into multiple statments that are trying
 * to be defined/assigned in the same line. Each command is separated by a comma, and we continue
 * to recursively call decls until there is no more comma being found. decls doesn't need an INT or
 * SEMI as it is contained within a stmt from above
 */
decls ::= decls:ds COMMA decl:d
          {: RESULT = new SequenceStmt(ds, d); :}
          |
          decl:d
          {: RESULT = d; :}
		  ;

         
         
/**Created this new statement called stmts to handle cases where we want multiple statements within the program
 * otherwise, if no arguments are given, the program will return nothing.
 */
stmts ::= {: RESULT = new EmptyStmt(); :}
          |
          stmt:s stmts:ss
          {: RESULT = new SequenceStmt(s, ss); :}
          ;
         
         
         
expr      ::= expr:l PLUS expr:r
              {: RESULT = new SumExpr(l, r); :}
	      |
              expr:l MINUS expr:r
              {: RESULT = new DifferenceExpr(l, r); :}
	      |
              expr:l TIMES expr:r
              {: RESULT = new ProductExpr(l, r); :}
	      |
              expr:l DIVIDE expr:r
              {: RESULT = new QuotientExpr(l, r); :}
	      |
              expr:l MOD expr:r
              {: RESULT = new RemainderExpr(l, r); :}
	      |
	          expr:l MORE expr:r
	          {: RESULT = new MoreExpr(l, r); :}
	      |
	         expr:l LESS expr:r
	          {: RESULT = new LessExpr(l, r); :}
	      |
	         expr:l MOREEQ expr:r
	          {: RESULT = new MoreEqExpr(l, r); :}
	      |
	         expr:l LESSEQ expr:r
	          {: RESULT = new LessEqExpr(l, r); :}
	      |
	         expr:l EQEQ expr:r
	          {: RESULT = new EqEqExpr(l, r); :}
	      |
	         expr:l NOTEQ expr:r
	          {: RESULT = new NotEqExpr(l, r); :}
	      |
              MINUS expr:e
              {: RESULT = new DifferenceExpr(new ConstExpr(0), e); :}
 	      %prec UMINUS
	      |
              NUMBER:n
              {: RESULT = new ConstExpr(Integer.parseInt(n)); :}
	      |
	          /**Added this expression based on phase two in the project. This allows the program to accept 
	           * procedures to be called with names. LETTER:l clumps the letters together of the name that
	           * the user has created i.e. "println"
	           */
	          LETTER:l LPAREN expr:e RPAREN 
              {: RESULT = new CallExpr(l, e); :}
	      |
              LPAREN expr:e RPAREN
              {: RESULT = e; :}
          |
              /**Added this expression for when someone calls just the name, the value 
               * associated will be loaded
               */
              LETTER:l
              {: RESULT = new LoadExpr(l, lleft); :}
	      ;
