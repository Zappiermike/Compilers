terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal LPAREN, RPAREN;
terminal UMINUS, ILLEGAL_CHAR;


//Added most of the following terminals listed below based on requirements listed in the project
terminal String NUMBER, LETTER, INT, IF, WHILE, ELSE, RETURN;
terminal SEMI, LCURLY, RCURLY, COMMA, EQUALS;
terminal MORE, LESS, MOREEQ, LESSEQ, EQEQ, NOTEQ;


non terminal Procedure program;
non terminal Stmt stmt;

// Adding a new SequenceProcedure called programs to handle multiple Procedures
non terminal SequenceProcedure programs;



/** Added a new non-terminal Statements called stmts, decl, and decls. stmts takes care of 
 * cases when we want multiple statements within the program. decl and decls handle the
 * situation when we want to define/assign multiple variables/values within one line,
 * each command being separated by a comma.
 */
non terminal Stmt stmts;
non terminal Expr expr;
non terminal Stmt decl;
non terminal Stmt decls;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence nonassoc MORE, LESS, MOREEQ, LESSEQ, EQEQ, NOTEQ, ELSE;
precedence left UMINUS;








/** SequenceProcedure called programs can handle multiple Procedures. 'programs' first looks
 *  to see if there is one or multiple Procedures. If there's just one, we run the code just
 *  like usual. If there are two or more Procedures then we recursively continue running
 *  Procedures until we are down to just one Procedure again
 */
programs ::= programs:m program:p
             {: m.add(p); RESULT = m; :}
             |
             program:p
             {: RESULT = new SequenceProcedure(p); :}
             ;

/** Program now has two paths to take depending on what is passed in.
 *  Each statement is separated by a semicolon that we created from a previous lab phase. Following the 
 *  statements, we end the program with a right curly bracket. The compilers has a choice depending on 
 *  whether there are given statements.
 */
program ::= INT LETTER:l LPAREN INT LETTER:ll RPAREN LCURLY
            {: SymbolTable.getTable().enterScope();
               String val = NameAllocator.getTempAllocator().next();
               SymbolTable.getTable().setVal(ll, val); :}
               stmts:s
               {: RESULT = new Procedure(l, ll, new SequenceStmt(s, new ReturnStmt(new ConstExpr(0)))); :}
               RCURLY
               {: SymbolTable.getTable().exitScope(); :}
            |
            INT LETTER:l LPAREN INT LETTER:ll RPAREN LCURLY
            {: SymbolTable.getTable().enterScope();
               String val = NameAllocator.getTempAllocator().next();
               SymbolTable.getTable().setVal(ll, val);
               RESULT = new Procedure(l, ll, new ReturnStmt(new ConstExpr(0))); :}
               RCURLY
               {: SymbolTable.getTable().exitScope(); :}
               ;



/**Created this new statement called stmts to handle cases where we want multiple statements within the program
 * otherwise, if no arguments are given, the program will return nothing.
 */
stmts ::= stmt:s stmts:ss
          {: RESULT = new SequenceStmt(s, ss); :}
          |
          stmt:s
          {: RESULT = s; :}
          ;
         


/** Statement has multiple options, depending on what is given to the parser from the scanner. 
 *  Multiple paths include regular statements, int declaration statements, assignment statements,
 *  looping statements like "if", "else", "while".
 */
stmt ::= expr:e SEMI
         {: RESULT = new ExprStmt(e); :}
         |
         INT decls:ds SEMI
         {: RESULT = ds; :}
         |
         LETTER:l EQUALS expr:e SEMI
         {: String pointer = SymbolTable.getTable().getVal(l);
            RESULT  = new AssignmentStmt(l,e, lleft, pointer); :}
         |
         IF LPAREN expr:e RPAREN stmt:s
         {: RESULT = new IfStmt(e,s); :}
         |
         IF LPAREN expr:e RPAREN stmt:s ELSE stmt:s2
         {: RESULT = new IfElseStmt(e,s,s2); :}
         |
         WHILE LPAREN expr:e RPAREN stmt:s
         {: RESULT = new WhileStmt(e,s); :}
         |
         LCURLY
         {: SymbolTable.getTable().enterScope(); :}
         stmts: s
         {: RESULT = s; :}
         RCURLY
         {: SymbolTable.getTable().exitScope(); :}
         |
         RETURN expr:e SEMI
         {: RESULT = new ReturnStmt(e); :}
         ;
         
         
/** decls is a statment that gets called when the parser runs into multiple statments that are trying
 * to be defined/assigned in the same line. Each command is separated by a comma, and we continue
 * to recursively call decls until there is no more comma being found. decls doesn't need an INT or
 * SEMI as it is contained within a stmt from above
 */
decls ::= decls:ds COMMA decl:d
          {: RESULT = new SequenceStmt(ds, d); :}
          |
          decl:d
          {: RESULT = d; :}
		  ;         
         
         
         
/** decl is a statement that gets called when the parser comes across something that needs to be 
 * defined. There are two options. The first is where we just define the variable name. There is
 * no need to add the INT or SEMI portion as decl is already contained between those two in stmt.
 * The second option is where we are declaring the variable as well as assigning it a value. 
 */
decl ::= LETTER:l
		 {: String pointer = SymbolTable.getTable().getLocal(l);
		 	String val = NameAllocator.getTempAllocator().next();
		 	if (pointer == null)
		 		SymbolTable.getTable().setVal(l, val);
		 	RESULT = new DeclarationStmt(l, lleft, pointer, val); :}
		 |
		 LETTER:l EQUALS expr:e
		 {: String pointer = SymbolTable.getTable().getLocal(l);
		 	String val = NameAllocator.getTempAllocator().next();
		 	if (pointer == null)
		 		SymbolTable.getTable().setVal(l, val);
		 	Stmt s = new DeclarationStmt(l, lleft, pointer, val);
		 	pointer = SymbolTable.getTable().getVal(l);
		 	Stmt s2 = new AssignmentStmt(l, e, lleft, pointer);
		 	RESULT = new SequenceStmt(s,s2); :}
		 ;


         
         
 /** expr is list of expressions that can be executed based on what the scanner gives the parser.
  *  Depending on what is parsed, the various java classes will be called with their according arguments.
 */        
expr      ::= expr:l PLUS expr:r
              {: RESULT = new SumExpr(l, r); :}
	      |
              expr:l MINUS expr:r
              {: RESULT = new DifferenceExpr(l, r); :}
	      |
              expr:l TIMES expr:r
              {: RESULT = new ProductExpr(l, r); :}
	      |
              expr:l DIVIDE expr:r
              {: RESULT = new QuotientExpr(l, r); :}
	      |
              expr:l MOD expr:r
              {: RESULT = new RemainderExpr(l, r); :}
	      |
	          expr:l MORE expr:r
	          {: RESULT = new MoreExpr(l, r); :}
	      |
	         expr:l LESS expr:r
	          {: RESULT = new LessExpr(l, r); :}
	      |
	         expr:l MOREEQ expr:r
	          {: RESULT = new MoreEqExpr(l, r); :}
	      |
	         expr:l LESSEQ expr:r
	          {: RESULT = new LessEqExpr(l, r); :}
	      |
	         expr:l EQEQ expr:r
	          {: RESULT = new EqEqExpr(l, r); :}
	      |
	         expr:l NOTEQ expr:r
	          {: RESULT = new NotEqExpr(l, r); :}
	      |
              MINUS expr:e
              {: RESULT = new DifferenceExpr(new ConstExpr(0), e); :}
 	      %prec UMINUS
	      |
              NUMBER:n
              {: RESULT = new ConstExpr(Integer.parseInt(n)); :}
	      |
	          /**Added this expression based on phase two in the project. This allows the program to accept 
	           * procedures to be called with names. LETTER:l clumps the letters together of the name that
	           * the user has created i.e. "println"
	           */
	          LETTER:l LPAREN expr:e RPAREN 
              {: RESULT = new CallExpr(l, e); :}
	      |
              LPAREN expr:e RPAREN
              {: RESULT = e; :}
          |
              /** Added this expression for when someone calls just the name, the value 
               *  associated will be loaded. Also adding a String pointer because LoadExpr
               *  now takes in three arguments. The pointer points to the value associated
               *  with the LETTER:l
               */
              LETTER:l
              {: String pointer = SymbolTable.getTable().getVal(l);
                 RESULT = new LoadExpr(l, lleft, pointer); :}
	      ;
